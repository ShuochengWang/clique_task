## Clique Task

### 问题描述
设计实现一个基于 Intel SGX 的图数据库系统，保证图查询操作的完整性和机密性。

1. 图查询操作在 enclave 中进行
2. 保证 client 和 enclave 之间的通信安全
3. 系统支持 CRUD 操作，即 Create, Read, Update, Delete
4. 数据库底层使用 neo4j
5. 支持计算最短路，计算过程在 enclave 中进行
6. 基于 SGX Sealing 进行数据加密和持久化
7. 加载图数据时进行数据完整性验证

### 问题分析
设计一个安全的系统，保证数据的完整性和机密性，首先可以分析数据所处的各个阶段，对各个阶段的数据进行分别保护。

#### Data in memory
保护内存中的数据，这是 TEE 最擅长的，enclave 中的数据是受保护的，可以保证其中数据的完整性和机密性。

#### Data in transit
保护传输中的数据，数据会通过网络传输，分为两个部分：
1. enclave 和 neo4j 数据库之间：使用加密通信，比如 bolt
2. enclave 和 client 之间：使用加密通信，比如 tls

#### Data at rest
保护持久化存储中的数据，即数据必须进行加密后才能保存到 enclave 外的持久化存储中，加密的同时还要保证数据的完整性。

### 威胁模型

#### 可信部分
- enclave
- client：因为 client 是明文数据的来源，如果 client 被攻陷，后面的安全系统毫无意义

#### 不可信部分
- client 和 enclave 之间的网络信道
- enclave 和 neo4j 之间的网络信道
- neo4j 及其持久化存储

#### 攻击者的能力
- 窃听 client 和 enclave 之间的网络信道
- 窃听 enclave 和 neo4j 之间的网络信道
- 查看和修改 neo4j 的持久化存储
- 攻陷 neo4j （或整个 host）获得 neo4j 的完全控制权

### 系统架构与设计

![](./image/arch.png)

- client: 明文数据的来源，位于移动端等端设备内，用户构建图查询，然后将图查询传输给云端的 enclave 中的 server，图查询计算完成后，server 将计算结果发送回 client，用户完成一次图查询计算
- enclave：
    - server: 负责与 client 之间进行安全通信，并将图查询交给 EncryptedGraph 来执行并获取计算结果。
    - EncryptedGraph：负责通过密码学算法对图查询计算进行机密性和完整性保护，与 neo4j 进行安全通信，将加密后的图查询交给 neo4j 执行。
- neo4j：保存加密后的图数据，响应 EncryptedGraph 的加密后的图查询。

#### 设计考量

##### 图查询要进行什么粒度的加密？

neo4j 使用 cypher 图查询语言，其中顶点和边，都是由若干个标签和若干个属性组成，在图查询中会通过标签、属性、关联关系等进行增删改查。
如果我们将整个节点或边完整加密，那么 neo4j 就无法通过标签、属性、关联关系等执行图查询了，neo4j 本身失去了存在意义。而 neo4j 必须存在，所以我们应该进行细粒度的加密，即对每条标签每条属性进行分别加密，这样 neo4j 就可以根据密文图查询来返回给我们密文结果，我们再解密获得明文结果。

##### neo4j 应该在 enclave 内还是外？

普通版 neo4j 是不支持加密计算、加密存储的，仅支持加密网络通信。
借助 LibOS 以及加密文件系统， neo4j 是有可能可以完整移植到 enclave 中的，但是可能会占用更多资源。重要的一点是，这样做似乎也不符合任务的立意。

##### 如何保证数据完整性？

对 neo4j 的标签、属性等进行逐项加密，本身只能保证机密性，无法保证完整性，被攻陷的 neo4j 可能会返回给我们错误的密文结果、或者部分密文结果、或者将正确的部分密文结果进行一些组合，无论哪种情况，使用不保证完整性的加密算法是无法判断的。

1. 方案1：在使用时将所有图数据都保存在 enclave 内存中，可以保证图数据本身的安全性，对所有图数据计算 Merkle Tree，将 Merkle Tree 的数据维护起来，并加密后持久化保存。在每次系统启动时，读取所有图数据到内存中，并读取 Merkle Tree来验证读取的数据是否正确。由于所有数据都在内存中，所以我们可以直接根据内存数据来计算图查询，自己实现图查询逻辑。
    - 缺点1：neo4j只用来保存数据，neo4j自身还不支持加密，neo4j的存在变得毫无意义，不如直接把图数据保存到加密文件系统
    - 缺点2：为了严格的完整性，必须要保证数据都在实时保护之下，而只有在 enclave 中才能确保这一点，如果数据在 enclave 外，即便现在验证 Merkle Tree 成功，后面数据也可能被修改而不自知，从而失去完整性。这样的解决方案意味着巨大的内存消耗，对于图很大的情况很不友好。
2. 方案2：图数据放在 enclave 外，enclave 内保存所有节点、边的哈希值。这样每次数据从 neo4j 中读取出来，都可以检查该数据的哈希值是否存在于保存的所有哈希值。
    - 缺点1：查询（即过滤）依然是 neo4j 进行的，neo4j 可以只返回部分数据给你、甚至是错误数据给你。例如想要节点A，neo4j却可以返回给我们节点B，仅根据哈希值我们只能判断返回的节点是完整的节点，不能判断是否是正确的节点。
    - 缺点2：难以更新哈希值，第一次创建数据时可以看见全部明文所以可以计算哈希值，后面在修改数据时不能保证拿到正确的节点和边，也就无法计算正确的新哈希值。

可以看到，设计中有很多 trade-off，实现强完整性的开销过大，因为我们设计实现了弱完整性机制:

###### 原始的明文节点：

标签：[plain_label1, plain_label2, ...] 

属性：[(plain_key1: plain_value1), (plain_key2: plain_value2), ...]

###### 新建节点和边的时候都添加一个唯一的 uid 到属性中，得到

标签：[plain_label1, plain_label2, ...] 

属性：[(uid: xxx)， (plain_key1: plain_value1), (plain_key2: plain_value2), ...]

###### 对所有标签和属性计算哈希值，并把哈希值添加到属性中，得到

标签：[plain_label1, plain_label2, ...] 

属性：[(hash: xxx)， (uid: xxx)， (plain_key1: plain_value1), (plain_key2: plain_value2), ...]

###### 对所有标签和属性进行加密并 base64 编码，得到

标签：[enc_label1, enc_label2, ...] 

属性：[(enc_hash: enc_xxx)， (enc_uid: enc_xxx)， (enc_key1: enc_value1), (enc_key2: enc_value2), ...]

其中，**base64 需要替换其中的特殊符号**，这是因为 neo4j 的图查询有相关命名要求。并且再给所有加密结果**添加一个前缀字母**，来满足 neo4j 的图查询命名要求。

经过这样的处理之后，我们可以保证每个节点本身的机密性完整性，准确的说，保证节点处在某个时刻的完整性，因为我们在更新数据时需要先从 neo4j 获取数据并写回，如果 neo4j 被攻陷，neo4j 返回不完整的结果会被我们发现，但是如果 neo4j 返回旧的结果，我们无法判断。

每次更新数据时都相应修改哈希值并写回，如果 neo4j 假装给我们写回，那么后续我们只能获得旧版本的完整数据。

###### 特殊处理边的 uid

边的 uid 是边的起点和终点的两个节点的 uid 的组合，在新建边的时候可以唯一确定。

这样做是为了在涉及边的图查询时我们可以验证计算的正确性，比如我们查询NODE_A-RELATION_R->NODE_B 的关联关系，就可以通过 uid 来确定 neo4j 返回给我们的结果是否是正确的关联关系，这一点在处理最短路时尤为重要，如果不记录 uid，在计算最短路时 neo4j 就可以随便返回几个完整的节点来假冒真实的最短路。

### 环境部署与测试

### 实现细节